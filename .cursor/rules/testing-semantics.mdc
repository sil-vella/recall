---
description:
globs: **/*.dart
alwaysApply: true
---

# Semantics-Based UI Targeting and Web Automation

This document explains how we expose Flutter widgets for automation via Semantics and how to target them in the web build (Chrome) and on macOS.

## What we added in code

- We wrap key widgets with `Semantics` and set both a human label and an identifier.
- On Web, `SemanticsData.identifier` becomes a DOM attribute `flt-semantics-identifier`.

Examples in the app:
- Burger button (open drawer): `identifier: drawer_open`
- Drawer container: `identifier: drawer_container`
- Drawer close button: `identifier: drawer_close`
- Drawer items: `identifier: drawer_item_<title>`

Reference: Flutter Semantics identifier → web `flt-semantics-identifier` attribute ([Flutter API](https://api.flutter.dev/flutter/semantics/SemanticsData/identifier.html)).

## Running on Web

1. Start Chrome in remote-debug mode (optional for CDP-based control):
```
/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome \
  --remote-debugging-port=9222 \
  --remote-debugging-address=127.0.0.1 \
  --user-data-dir=/tmp/chrome-debug \
  --no-first-run \
  --disable-default-apps
```

2. Run Flutter on a fixed port (optional but convenient):
```
flutter run -d chrome --web-port=3000
```

## DevTools console helpers (Web)

Enable semantics (first time only), click burger, wait for drawer, then click close. Paste in DevTools Console:
```js
(async () => {
  const sleep = ms => new Promise(r => setTimeout(r, ms));

  // Enable semantics (first time only)
  document.querySelector('flt-semantics-placeholder[role="button"]')?.click();

  const opened = () =>
    !!document.querySelector('[flt-semantics-identifier="drawer_close"]') ||
    document.querySelectorAll('[flt-semantics-identifier^="drawer_item_"]').length > 0;

  // Find burger button
  const root = document.querySelector('[flt-semantics-identifier="drawer_open"]');
  if (!root) { console.warn('drawer_open not found'); return; }
  const tappable = root.querySelector('[flt-tappable]') || root;

  // A) Direct click
  tappable.click();
  await sleep(400);
  if (opened()) { console.log('Opened via click'); return; }

  // B) Keyboard activation (Enter/Space)
  tappable.focus?.();
  ['keydown','keyup'].forEach(type =>
    tappable.dispatchEvent(new KeyboardEvent(type, {bubbles:true, key:'Enter', code:'Enter', keyCode:13, which:13}))
  );
  await sleep(300);
  if (opened()) { console.log('Opened via Enter'); return; }

  ['keydown','keyup'].forEach(type =>
    tappable.dispatchEvent(new KeyboardEvent(type, {bubbles:true, key:' ', code:'Space', keyCode:32, which:32}))
  );
  await sleep(300);
  if (opened()) { console.log('Opened via Space'); return; }

  // C) Synthesized mouse events at center (CanvasKit-friendly)
  const r = tappable.getBoundingClientRect();
  const cx = r.left + r.width / 2, cy = r.top + r.height / 2;
  const target = document.elementFromPoint(cx, cy) || tappable;
  ['mousemove','mousedown','mouseup','click'].forEach(type => {
    target.dispatchEvent(new MouseEvent(type, {
      bubbles: true, cancelable: true, view: window,
      clientX: cx, clientY: cy, buttons: 1, button: 0
    }));
  });

  await sleep(500);
  if (opened()) { console.log('Opened via synthesized mouse events'); return; }

  console.warn('Drawer did not open. Ensure the burger is visible and hot-restart if needed.');
})();
```

Query helpers:
```js
// Find by identifier
document.querySelector('[flt-semantics-identifier="drawer_close"]')
document.querySelectorAll('[flt-semantics-identifier^="drawer_item_"]')
```

Why not plain `element.click()`?
- Flutter Web (CanvasKit) listens for real pointer events on the canvas/glass pane. A bare DOM `click()` on the semantics wrapper may not generate those. The script above clicks the inner tappable node or synthesizes mouse events at the element’s coordinates.

## CDP (Chrome DevTools Protocol) option

If you prefer automation via CDP (e.g., MCP DevTools integration):
- Enable `Accessibility` domain, locate button by AX role/name (e.g., name `drawer_open`), resolve the node, and call `click()` or synthesize events. This is robust when dealing with shadow DOM.

## macOS native app (optional)

For the desktop build, Semantics map to macOS Accessibility. You can target by the semantics label via AppleScript:
```applescript
tell application "System Events"
  tell process "YourAppName"
    click (first UI element of window 1 whose description is "drawer_open")
  end tell
end tell
```
Make sure Terminal/Script Editor has Accessibility permission.

## Adding new targets

- Wrap the widget with `Semantics(label: 'your_label', identifier: 'your_label', button: true, child: ...)`.
- For list items: `identifier: 'list_item_<id>'` patterns make them easy to query.

## Troubleshooting

- Hot-restart after adding semantics so identifiers are injected.
- Ensure the control is visible; semantics for offstage widgets may not be emitted.
- On Web, always enable the placeholder button (`flt-semantics-placeholder`) once per session.
